"""
Created on Mon Sep 28 11:55:21 2020

@author: yluo89
"""

import h5py, collections, os, sys
import numpy as np
import pandas as pd

class load_h5_bnp():
    
    def __init__(self, smp = None, datadir = None, img_tag = None, 
                 pv_theta = None, elms = None):
        self.smp = smp
        self.datadir = datadir
        self.img_tag = img_tag
        self.pv_theta = pv_theta
        self.elms = elms
        self.loadedData = collections.defaultdict(list)
        self.data_pd = pd.DataFrame()
        self.temp = {}
    
    def get_theta (self, h5pv, pv_name):
        '''
        return the angular position (float) of a 2D scan
        for the current BNP data (h5 files) automatically generated by XRF-Maps
        h5py is h5py.File(filename, 'r')['MAPS']['extra_pvs']
        pv_name of rotation stage is 9idbTAU:SM:ST:ActPos
        '''
        pvs = h5pv[0,:].tolist()
        pv_index = pvs.index(pv_name)
        theta = float(h5pv[1,pv_index])
        return theta
    
    # Can be improve by checking more img_tag so reduce file open and close?    
    def read_h5_bnp(self, fname, img_tag, angle_pv, showprg, printscaler, fitted):
        '''
        return a dictionary including 5 keys: 'theta', 'xrf', 'channels', 'xval', 'yval' 
        theta: rotation angle
        xrf: 3-dimensional numpy array from ['MAPS']['XRF_roi']
        channels: a list of channel names from ['MAPS']['channel_names']
        xval: required x positions
        yval: required y positions
        
        '''
        data_dict = {}
        with h5py.File(fname, 'r') as dat:
            fields = dat['MAPS'].keys()
            ch = None
            
            # to get the value of 'theta': the rotation angle
            if ('extra_pvs' in fields) & (angle_pv is not None):
                ext_pv = dat['MAPS']['extra_pvs'][:]
                try:
                    theta = self.get_theta(ext_pv, angle_pv)
                except:
                    print('No %s pv found in scan %s'%(angle_pv, fname))
                    theta = -1
            else:
                theta = 1e3
               
            xrfdata = None
            ch = None
            
            # to get the values for 'xrf': XRF_roi data; and for 'channels'
            if (img_tag == 'MAPS'):
                xrfdata = dat[img_tag]['XRF_fits'][:] if fitted else dat[img_tag]['XRF_roi']
                scaler = dat[img_tag]['scaler_names'][:].astype('U13').tolist()
                if printscaler:
                    print(scaler)
                scalerdata = dat[img_tag]['scalers'][:]
                scalerch = ['ds_ic','us_ic']
                sdata = np.zeros((len(scalerch),xrfdata[0].shape[0],xrfdata[0].shape[1]))
                for idx, c in enumerate(scalerch):
                    c_index = scaler.index(c) if c in scaler else scaler.index(c.upper())
                    sdata[idx,:,:] = scalerdata[c_index,:,:]
                xrfdata = np.vstack((xrfdata,sdata))
                ch = dat[img_tag]['channel_names'][:].astype('U13').tolist()
                ch.append(scalerch[0])
                ch.append(scalerch[1])
                
            else :
                try:
                    fields = dat[img_tag].keys()
                    if 'channel_names' in fields:
                        xrfdata = dat[img_tag]['data'][:]
                        ch = dat[img_tag]['channel_names'][:].astype('str').tolist()
                    elif 'data_names' in fields:
                        xrfdata = dat[img_tag]['data'][:]
                        ch = dat[img_tag]['data_names'][:].astype('str').tolist()
                    else:
                        print('not found field of channel_names in dat[%s]'%(img_tag))
                except:
                    print('Image tag: %s does not exist\n'%(img_tag))
                    return None
            
            data_dict['theta'] = theta
            data_dict['xrf'] = xrfdata
            data_dict['channels'] = ch
#             data_dict['channel_unit'] = dat[img_tag]['channel_units'][:].astype('U13').tolist()
            data_dict['xval'] = dat[img_tag]['x_axis'][:]
            data_dict['yval'] = dat[img_tag]['y_axis'][:]
            data_dict['eng'] = dat['MAPS']['energy'][:]
            data_dict['intspec'] = dat['MAPS']['int_spec'][:]
            data_dict['xrf_qval'] = dat['MAPS']['XRF_fits_quant'][:] if fitted else None
#             if data_dict['xrf_qval'] is not None: print(data_dict['xrf_qval'].shape)
        
        if showprg:
            print('Loading %s'%(fname))
            
        return data_dict
        
    
    def dataPadding(self, df, elms):
        tomoPrj_dict = {}
        
        if (df.empty == True) | (len(elms) == 0):
            print("Empty dataFrame or no element specified \n")
            return None
        else:
            e = elms[0]
            ymax = max([row[e].shape[0] for i, row in df.iterrows()])
            xmax = max([row[e].shape[1] for i, row in df.iterrows()])
            
            for e in elms:
                center_data = np.zeros([len(df), ymax, xmax])
                for i, row in df.iterrows():
                    data_raw = row[e]
                    raw_y, raw_x = data_raw.shape
                    dy = (ymax - raw_y)//2
                    dx = (xmax - raw_x)//2
                    center_data[i, dy:raw_y+dy, dx:raw_x+dx] = data_raw
                
                tomoPrj_dict[e+'_pad'] = center_data
        
        return tomoPrj_dict
    
    
    
    def load_h5(self, ext = '.h5', padding = False, printch = False, showprg=True, printscaler=False, fitted = False):
        for f in os.listdir(self.datadir):
            if f[-len(ext):] == ext:
                fname = os.path.join(self.datadir, f)
                data = None
                try:
                    data = self.read_h5_bnp(fname, self.img_tag, self.pv_theta, showprg, printscaler, fitted)
                except:
                    print('can not load file: %s\n'%(fname))
                if data is not None:
                    self.loadedData['theta'].append(data['theta'])
                    self.loadedData['scan_num'].append(f[:-3])
                    if printch:
                        print(data['channels'])
                    c_index = [data['channels'].index(e) for e in self.elms]
                    for i, e in zip(c_index, self.elms):
                        xrfdata = data['xrf'][i, :, :]
                        if fitted & (i < (data['xrf'].shape[0]-2)):
                            xrfdata = data['xrf'][i] / data['xrf_qval'][2,0,i] / data['xrf'][-2]
                        self.loadedData[e].append(xrfdata)
                    self.loadedData['img_tag'].append(self.img_tag)
                    self.loadedData['xval'].append(data['xval'])
                    self.loadedData['yval'].append(data['yval'])
                    self.loadedData['eng'].append(data['eng'])
                    self.loadedData['intspec'].append(data['intspec'])
                else:
                    print('No data loaded %s \n'%(fname))
        
        # Convert dict to dataframe object
        self.data_pd = pd.DataFrame(self.loadedData)
        
        # Maps with small size is padded with zeros, so that all projections 
        # have the same number of x- and y- pixels
        if padding is True:
            padded_data = self.dataPadding(self.data_pd, self.elms)
            if padded_data is not None:
                padded_dict = {}
                # self.temp = padded_data
                for e in self.elms:
                    for i in padded_data[e + '_pad']:
                        self.loadedData[e + '_pad'].append(i)
                        
                self.data_pd = pd.DataFrame(self.loadedData)
        
        # Sort data using sample theta
        if self.data_pd.empty is False:
            self.data_pd = self.data_pd.sort_values(by=['theta'])
            self.data_pd = self.data_pd.reset_index(drop=True)
                

def load_single_h5(fpath:'file path', fields:'fields to be loaded'=['XRF_roi', 'XRF_fits', 'XRF_fits_quant', 
                                                            'x_axis', 'y_axis', 'channel_names', 
                                                            'scaler_names', 'scalers', 'scan_time_stamp']):
    h5dic = {}
    with h5py.File(fpath, 'r') as dat:
        print('Loading file: %s'%fpath)
        k = list(dat['MAPS'].keys())
        for c in fields:
            if 'names' not in c:
                d = dat['MAPS/%s'%c][:] if c in k else None
            else:
                d = dat['MAPS/%s'%c][:].astype(str).tolist()
            h5dic.update({c:d})
    return h5dic
                

# get energy calibration parameters from overwrite files... 
def getEngCaliParms_from_overwrite(folder:'folder path of where files stored', num_detector = 7, num_channel = 2048):
    engCalibration = {}
    for i in range(num_detector):
        owf = os.path.join(folder, 'maps_fit_parameters_override.txt%d'%i)
        with open(owf, 'r') as f:
            offset, slope, quad = 0,0,0
            for l in f:
                if 'CAL_OFFSET_[E_OFFSET]:' in l:
                    offset = float(l.split(':')[1].replace('\n', ''))
                elif 'CAL_SLOPE_[E_LINEAR]:' in l:
                    slope = float(l.split(':')[1].replace('\n', ''))
                elif 'CAL_QUAD_[E_QUADRATIC]:' in l:
                    quad = float(l.split(':')[1].replace('\n', ''))
            xval = np.arange(0, num_channel, 1)
            xval = offset + slope * xval + quad * (xval**2)
            engCalibration.update({i:{'offset':offset, 'slope':slope, 'quad':quad, 'xval':xval}})
    return engCalibration
        
                
                                
 